{"componentChunkName":"component---src-templates-post-js","path":"/[筆記]認識 this 和 call、apply、bind/","result":{"data":{"markdownRemark":{"html":"<h1>認識 this 及相關的 JavaScript method (call、apply、bind)</h1>\n<p>在 JavaScript 中 this 常會因不同情況下代表不同的值，同時也想了解 call、apply 和 bind 的使用方法，所以做這個筆記。</p>\n<h3>在物件導向時</h3>\n<p>在物件導向(OOP)的環境中，this 會指向該類別(class)本身。</p>\n<pre><code class=\"language-js\">class flower {\r\n  constructor(name) {\r\n    this.name = name\r\n  }\r\n  callName() {\r\n    console.log(this.name)\r\n  }\r\n}\r\n\r\nvar sun_flower = new flower(\"sun_flower\")\r\nsun_flower.callName() //\"sun_flower\"\n</code></pre>\n<h3>用物件的方式呼叫</h3>\n<p>在 JavaScript 裡面 this 會因為 call 的方式不同會有不一樣的值，如果是用物件(object)的方式呼叫，會指向物件本身。</p>\n<pre><code class=\"language-js\">var obj = {\r\n  myTeam: \"arsenal\",\r\n  callMyTeam: function () {\r\n    console.log(this.myTeam)\r\n  },\r\n}\r\nobj.callMyTeam() //\"arsenal\"\n</code></pre>\n<p>但要注意如果我們用函式的方法呼叫 this，會指向全域環境。</p>\n<pre><code class=\"language-js\">var myTeam = \"chelsea\"\r\nvar obj = {\r\n  myTeam: \"arsenal\",\r\n  callMyTeam: function () {\r\n    console.log(this.myTeam)\r\n  },\r\n}\r\nconst callMyTeam = obj.callMyTeam //注意這邊賦值了一個新的函式\r\ncallMyTeam() //\"chelsea\"\n</code></pre>\n<h3>用函式的方法來 call this</h3>\n<p>在非物件或物件導向的情況下，如果我們用一般函式的方法來 call this，this 會指向全域環境，所以依據全域環境(runtime)會回傳不同的值。\r\n假若是瀏覽器會回傳 <code>window</code>，Node.js 則會回傳<code>global</code></p>\n<pre><code class=\"language-javascript=\">function test() {\r\n\tfunction inner() {\r\n\t\tconsole.log(this)\r\n\t}\r\n\tinner()\r\n}\r\ntest()\n</code></pre>\n<p>上面的情況是在非\"嚴格模式\"的狀況下，但假設我們今天在\"嚴格模式\"下執行函式 call this，this 的值會變成 undefined。</p>\n<pre><code class=\"language-javascript=\">'use strict';\r\nfunction test() {\r\n\tfunction inner() {\r\n\t\tconsole.log(this)\r\n\t}\r\n\tinner()\r\n}\r\ntest() //undefined\n</code></pre>\n<h3>箭頭函式(arrow function)</h3>\n<p>用 arrow function 跟在一般 function 裡面 call this 會有不一樣的行為(可以當作一個特例)，在 arrow function 裡面會回傳 this 原本建立作用域(scope)的賦值，沒有賦值就會回傳 undefined，而不是像一般 function 會回傳 runtime 環境或 undefined。</p>\n<p>例如下面的範例，this 的 scope 是 obj 這個物件，所以 this.myTeam 就會回傳 obj 裡面的 MyTeam value。</p>\n<pre><code class=\"language-js\">this.myTeam = \"arsenal\"\r\n\r\nconst obj = {\r\n  callMyTeam: () => {\r\n    console.log(this.myTeam)\r\n  },\r\n}\r\n\r\nobj.callMyTeam() //\"arsenal\"\n</code></pre>\n<p>在拿另外一個例子來說，在 class 裡面的 scope 就是 class 本身。</p>\n<pre><code class=\"language-javascript=\">class test {\r\n  run() {\r\n    console.log('run this:', this)\r\n    setTimeout(() => {\r\n      console.log(this)\r\n    },180)\r\n  }\r\n}\r\n\r\nconst t = new test()\r\nt.run() //run this: test {}, test{}\n</code></pre>\n<h3>this 在 DOM 監聽裡面的回傳值</h3>\n<p>在瀏覽器 DOM 物件中 call this 會回傳正在執行的物件。</p>\n<pre><code class=\"language-javascript=\">document.querySelector('#obj').addEventListener('click', () => {\r\n  consol.log(this) //'obj'\r\n})\n</code></pre>\n<h3>知道了 this 在各個情況下所代表的值後，可以在繼續了解如何運用不同的 JavaScript method 來操作 this 囉。</h3>\n<h3>先來談談 call、apply</h3>\n<p>call 和 apply 其實很相像，參數我們可以傳入 this 和其他參數，會回傳一個函式運算的結果，我們先來看看兩個的語法，</p>\n<ol>\n<li>call : <code>fun.call(thisArg, arg1, arg2, ...)</code></li>\n<li>apply : <code>fun.apply(thisArg, [argsArray])</code></li>\n</ol>\n<p>可以看到兩個傳入的第一個參數都是 this 的值，差別在於後面的參數一個是傳入以<code>,</code>分開的不同參數，另一個則是陣列。</p>\n<p>我們先來看看如何用 call 或 apply 來指定 this 的值</p>\n<pre><code class=\"language-js\">function stringnify() {\r\n  return this.toString()\r\n}\r\n\r\nconsole.log(stringnify.call(1)) //\"1\"\n</code></pre>\n<p>如果要指定其他參數會變成如下列例子。</p>\n<pre><code class=\"language-javascript=\">'use strict';\r\nfunction test(a, b, c) {\r\n  console.log(this)\r\n\tconsole.log(a ,b ,c)\r\n}\r\ntest.call(123, 1, 2, 3) //回傳 123(this 的值) 1 2 3(其他參數)\r\ntest.apply(123, [1, 2, 3]) //回傳 123(this 的值) 1 2 3(其他參數)\n</code></pre>\n<h3>接著再來看看 bind 的用法</h3>\n<p>function 可以用 bind 來綁定 this 的值，並且會建立一個新的函式，當該函式被呼叫的時候會取用 this 的值。bind 綁定後的函式就可以直接用ㄧ般 call function 的方式來使用。但注意的是之後 variable 的 this 值就不能再改變了。</p>\n<p>我們先來看看 bind 的基本用法。</p>\n<pre><code class=\"language-js\">globalThis.name = \"kevin\"\r\n\r\nvar obj = {\r\n  name: \"michael\",\r\n  getName: function () {\r\n    console.log(this.name)\r\n  },\r\n}\r\n\r\nobj.getName() //\"michael\",\"this 會指向 obj\r\n\r\nvar retrieveName = obj.getName\r\nconst boudToName = retrieveName.bind(obj)\r\nretrieveName() //\"kevin\"，this 會指向全域環境\r\nboudToName() //\"michael\",\"this 會指向 obj\n</code></pre>\n<h3>在學過各種 this 代表的值及不同 method 之後，來做個小練習複習一下吧。</h3>\n<pre><code class=\"language-javascript=\">'use strict'\r\n\r\nfunction log() {\r\n  console.log(this);\r\n}\r\n//call, apply\r\nvar a = { a: 1, log: log };\r\nvar b = { a: 2, log: log };\r\n\r\nlog(); //嚴格模式 -> undefined\r\na.log(); //{a:1, log: log}\r\nb.log.apply(a) //{a:1, log: log}\r\nb.log.call(a) //{a:1, log: log}\r\n\r\n\r\n//接著我們回顧一下 this 的不同 call 法會回傳什麼東西\r\nconst obj = {\r\n  num: 1,\r\n  test : function() {\r\n    console.log(this)\r\n  }\r\n}\r\n\r\n\r\nobj.test() // obj\r\nconst c = obj.test\r\nc() //嚴格模式，undefined\r\n\r\n//如果今天想要有一個函式可以綁定 obj 跟 obj.test ，我們可以用 bind()\r\nconst d = obj.test.bind(obj)\r\nd() //obj\r\n\r\n//但假如今天已經用 bind 綁定 this 的話，後面就算用 call 也無法更改了\r\nd.call('123') //obj\n</code></pre>\n<h6>tags: <code>week16</code> <code>物件導向</code> <code>OOP</code> <code>this</code></h6>","frontmatter":{"title":"[筆記]認識 this 和 call、apply、bind"}}},"pageContext":{"slug":"/[筆記]認識 this 和 call、apply、bind/"}},"staticQueryHashes":[]}