{"componentChunkName":"component---src-templates-post-js","path":"/[演算法]Enumerate All Primes To N/","result":{"data":{"markdownRemark":{"html":"<h3>題目</h3>\n<p>給定一個 integer > 0，然後列舉所有的質數並用一個 array 回傳。\n例如:</p>\n<pre><code class=\"language-js\">input: 10,\noutput: [2,3,5,7]\n</code></pre>\n<h3>自己的思路</h3>\n<p>首先先搞清楚質數的定義就是，除了 1 和 integer 本身外沒有其他的因數。\n所以這題我是先把確認質數的 function 寫出來。</p>\n<pre><code class=\"language-js\">function isPrime(integer) {\n  let factor = [1]\n  for (let i = 2; i &#x3C;= integer; i++) {\n    if (integer % i === 0) {\n      factor.push(i)\n    }\n  }\n  if (factor.length === 2) {\n    return integer\n  }\n  return\n}\n</code></pre>\n<p>然後再針對 input 的值做遍歷。</p>\n<pre><code class=\"language-js\">let primes = []\nfor (let i = 2; i &#x3C; n; i++) {\n  if (isPrime(i)) {\n    primes.push(i)\n  }\n}\nreturn primes\n</code></pre>\n<p>完整的 code 如下</p>\n<pre><code class=\"language-js\">const enumeratePrimes = n => {\n  //1\n  if (n === 1) return []\n  //isPrime\n  function isPrime(integer) {\n    let factor = [1]\n    for (let i = 2; i &#x3C;= integer; i++) {\n      if (integer % i === 0) {\n        factor.push(i)\n      }\n    }\n    if (factor.length === 2) {\n      return integer\n    }\n    return\n  }\n  //traverse 1 to n\n  let primes = []\n  for (let i = 2; i &#x3C; n; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n</code></pre>\n<p>因為我用了兩個 for loop 而且都是直接 interate n 次，所以時間複雜度應該是 O(n^2)</p>\n<h3>課程的思路</h3>\n<p>課程的解法反而是<strong>反面列舉</strong>，先把會是非質數的部分列出來並剔除以後，就知道哪些是質數了。\n所以步驟如下:</p>\n<ol>\n<li>建立一個 length 為 n 的陣列，然後把值都設為 true，預設為都是質數，代表 0~n-1 都是質數</li>\n<li>因為我們都知道 0、1 兩個數非質數先剔除掉</li>\n<li>接下來遍歷 2~n-1 的數，找出他們的倍數，必定就會是非質數，等到剔除完就只剩質數了，再把質數 push 到 output array<br>\n如下圖，舉 n = 10 為例子，先把 2 的倍數刪掉(4、6、8、10)，緊接著是 3 的倍數(9)，剩下來的遍歷因為都不符合條件，就完成演算\n<img src=\"https://i.imgur.com/s3dcOXn.png\" alt=\"\"></li>\n<li>剩下我們只需要回傳 output array 就是答案了</li>\n</ol>\n<pre><code class=\"language-js\">const enumeratePrimes = n => {\n  //n=1\n  if (n &#x3C;= 1) {\n    return []\n  }\n\n  const output = []\n  //Declare a Boolean Array for storing if a number is prime or not\n  const isPrime = Array(n).fill(true)\n\n  // Since 0 and 1 are not prime we declare them false explicitly\n  isPrime[0] = false\n  isPrime[1] = false\n  //check all possible not prime number and mark them false\n  for (let i = 0; i &#x3C; n; i++) {\n    // Only check if isPrime[i]==true\n    if (isPrime[i]) {\n      // Mark all the factor of (i) as Not Prime\n      for (let j = i + i; j &#x3C; n; j += i) {\n        isPrime[j] = false\n      }\n      //Accumulating all the prime numbers in out ans list\n      output.push(i)\n    }\n  }\n\n  return output\n}\n</code></pre>\n<h3>心得</h3>\n<ul>\n<li>我覺得這題用反面列舉的方式，很突破我自己線性思考的方式，因為之前都習慣是找出題目要的，但其實只要剔除題目不要的就會是答案，所以下次做題前可以先評估正面或反面列舉的難易度再決定方法。</li>\n<li>課程用的 array method 先把陣列用 boolean 填滿來代表 isPrime，可以建立一個決定是否演算的機制，可以學起來。</li>\n</ul>\n<h3>reference</h3>\n<p><a href=\"https://backtobackswe.com/platform/content/enumerate-all-primes-to-n\">Enumerate All Primes To N</a></p>","frontmatter":{"title":"[演算法]Enumerate All Primes To N"}}},"pageContext":{"slug":"/[演算法]Enumerate All Primes To N/"}},"staticQueryHashes":[]}