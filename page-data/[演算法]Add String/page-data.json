{"componentChunkName":"component---src-templates-post-js","path":"/[演算法]Add String/","result":{"data":{"markdownRemark":{"html":"<h3>題目</h3>\n<ul>\n<li>給兩個包含數字的 string ，回傳他們相加結果的 string。\r\n例如:</li>\n</ul>\n<pre><code class=\"language-js\">input: \"123\", \"45\"\r\noutput: \"168\"\n</code></pre>\n<ul>\n<li>限制: 不可以把 string 轉換為 intiger</li>\n</ul>\n<h3>自己的解法</h3>\n<p>這題一開始只有想到或許可以使用位元運算，但具體實踐方法沒什麼頭緒，所以先去複習了 <a href=\"%E4%BD%8D%E5%85%83%E9%81%8B%E7%AE%97%E5%AD%90.md\">位元運算子</a>，後來想到說既然可以透過拆解 string 為一個一個數字的方式，那透過不同數字的 charCode 應該可以拿到數值，用另一種方式取得 integer。</p>\n<pre><code class=\"language-js\">const addStrings = (a, b) => {\r\n  const length = a.length > b.length ? a.length : b.length\r\n  let result = 0\r\n\r\n  for (let i = 1; i &#x3C;= length; i++) {\r\n    const numA = a[a.length - i].charCodeAt()\r\n      ? a[a.length - i].charCodeAt() - \"0\".charCodeAt()\r\n      : 0\r\n    const numB = b[b.length - i]\r\n      ? b[b.length - i].charCodeAt() - \"0\".charCodeAt()\r\n      : 0\r\n    const numAdd = (numA + numB) * Math.pow(10, i - 1)\r\n    result += numAdd\r\n  }\r\n  return result.toString()\r\n}\n</code></pre>\n<p>但用這種方法會受到 max integer 的限制(-(2^53-1) &#x3C; x &#x3C; 2^53-1)。\r\n例如輸入<code>1111111111111111111111111</code>、<code>1</code> 會得到 <code>1.1111111111111111e+24</code></p>\n<h3>求助解答</h3>\n<p>這題偷看了解答，解答提供另一種思考方式，透過 pointer 及 carrier 來一次一次相加每一位數的，並且透過字串拼接的方式來組合成答案，因為 string 的最大長度理論上可以達到 2^53-1(約 9PB)，所以可以處理的數值比用 number 運算來的大多了。</p>\n<pre><code class=\"language-js\">const addStrings = (a, b) => {\r\n  let i = a.length - 1\r\n  let j = b.length - 1\r\n  let carry = 0\r\n  let result = \"\"\r\n  //針對每一個 digit 相加，並組合 string\r\n  while (i >= 0 || j >= 0) {\r\n    let sum = carry\r\n    if (i >= 0) {\r\n      var numA = a[i] - \"0\"\r\n      sum += numA\r\n      i--\r\n    }\r\n    if (j >= 0) {\r\n      var numB = b[j] - \"0\"\r\n      sum += numB\r\n      j--\r\n    }\r\n    result += (sum % 10).toString()\r\n    //更新 carry\r\n    carry = parseInt(sum / 10)\r\n  }\r\n  //檢查是否有 leftover carry\r\n  if (carry) {\r\n    result += carry\r\n  }\r\n  return result.split(\"\").reverse().join(\"\")\r\n}\r\naddStrings(\"999\", \"1\") //\"1000\"\n</code></pre>\n<h3>心得</h3>\n<ol>\n<li>還是有一些語法不太熟，如 reverse()、join() 這些 array method</li>\n<li>學到了 carrier 的技巧，可以帶一些要給下一次 loop 使用的參數。</li>\n<li>本題時間複雜度，O(n)。</li>\n</ol>\n<h3>reference</h3>\n<p><a href=\"https://leetcode.com/problems/add-strings/\">https://leetcode.com/problems/add-strings/</a></p>","frontmatter":{"title":"[演算法]Add String"}}},"pageContext":{"slug":"/[演算法]Add String/"}},"staticQueryHashes":[]}